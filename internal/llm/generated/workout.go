// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package generated

import "encoding/json"
import "fmt"
import "github.com/atombender/go-jsonschema/pkg/types"
import "reflect"
import "regexp"

type NullableInteger *int

type NullableNumber *float64

type NullableString *string

type PostWorkout struct {
	// CompletionTimeMinutes corresponds to the JSON schema field
	// "completion_time_minutes".
	CompletionTimeMinutes *int `json:"completion_time_minutes" yaml:"completion_time_minutes" mapstructure:"completion_time_minutes"`

	// Notes corresponds to the JSON schema field "notes".
	Notes *string `json:"notes" yaml:"notes" mapstructure:"notes"`

	// PerceivedDifficulty corresponds to the JSON schema field
	// "perceived_difficulty".
	PerceivedDifficulty *int `json:"perceived_difficulty" yaml:"perceived_difficulty" mapstructure:"perceived_difficulty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PostWorkout) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["completion_time_minutes"]; raw != nil && !ok {
		return fmt.Errorf("field completion_time_minutes in PostWorkout: required")
	}
	if _, ok := raw["notes"]; raw != nil && !ok {
		return fmt.Errorf("field notes in PostWorkout: required")
	}
	if _, ok := raw["perceived_difficulty"]; raw != nil && !ok {
		return fmt.Errorf("field perceived_difficulty in PostWorkout: required")
	}
	type Plain PostWorkout
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.CompletionTimeMinutes != nil && 300 < *plain.CompletionTimeMinutes {
		return fmt.Errorf("field %s: must be <= %v", "completion_time_minutes", 300)
	}
	if plain.CompletionTimeMinutes != nil && 1 > *plain.CompletionTimeMinutes {
		return fmt.Errorf("field %s: must be >= %v", "completion_time_minutes", 1)
	}
	if plain.PerceivedDifficulty != nil && 10 < *plain.PerceivedDifficulty {
		return fmt.Errorf("field %s: must be <= %v", "perceived_difficulty", 10)
	}
	if plain.PerceivedDifficulty != nil && 1 > *plain.PerceivedDifficulty {
		return fmt.Errorf("field %s: must be >= %v", "perceived_difficulty", 1)
	}
	*j = PostWorkout(plain)
	return nil
}

type Set struct {
	// ActualReps corresponds to the JSON schema field "actual_reps".
	ActualReps *int `json:"actual_reps" yaml:"actual_reps" mapstructure:"actual_reps"`

	// ActualWeight corresponds to the JSON schema field "actual_weight".
	ActualWeight NullableNumber `json:"actual_weight" yaml:"actual_weight" mapstructure:"actual_weight"`

	// Equipment corresponds to the JSON schema field "equipment".
	Equipment string `json:"equipment" yaml:"equipment" mapstructure:"equipment"`

	// Exercise corresponds to the JSON schema field "exercise".
	Exercise string `json:"exercise" yaml:"exercise" mapstructure:"exercise"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Must corresponds to the JSON schema field "must".
	Must bool `json:"must" yaml:"must" mapstructure:"must"`

	// Notes corresponds to the JSON schema field "notes".
	Notes NullableString `json:"notes" yaml:"notes" mapstructure:"notes"`

	// Order corresponds to the JSON schema field "order".
	Order int `json:"order" yaml:"order" mapstructure:"order"`

	// RestS corresponds to the JSON schema field "rest_s".
	RestS int `json:"rest_s" yaml:"rest_s" mapstructure:"rest_s"`

	// Rir corresponds to the JSON schema field "rir".
	Rir *int `json:"rir" yaml:"rir" mapstructure:"rir"`

	// Superset corresponds to the JSON schema field "superset".
	Superset *string `json:"superset" yaml:"superset" mapstructure:"superset"`

	// TargetReps corresponds to the JSON schema field "target_reps".
	TargetReps interface{} `json:"target_reps" yaml:"target_reps" mapstructure:"target_reps"`

	// TargetWeight corresponds to the JSON schema field "target_weight".
	TargetWeight interface{} `json:"target_weight" yaml:"target_weight" mapstructure:"target_weight"`

	// Tier corresponds to the JSON schema field "tier".
	Tier SetTier `json:"tier" yaml:"tier" mapstructure:"tier"`
}

type SetTier string

const SetTierA SetTier = "A"
const SetTierB SetTier = "B"
const SetTierC SetTier = "C"
const SetTierW SetTier = "W"

var enumValues_SetTier = []interface{}{
	"W",
	"A",
	"B",
	"C",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetTier) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetTier {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetTier, v)
	}
	*j = SetTier(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Set) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actual_reps"]; raw != nil && !ok {
		return fmt.Errorf("field actual_reps in Set: required")
	}
	if _, ok := raw["actual_weight"]; raw != nil && !ok {
		return fmt.Errorf("field actual_weight in Set: required")
	}
	if _, ok := raw["equipment"]; raw != nil && !ok {
		return fmt.Errorf("field equipment in Set: required")
	}
	if _, ok := raw["exercise"]; raw != nil && !ok {
		return fmt.Errorf("field exercise in Set: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Set: required")
	}
	if _, ok := raw["must"]; raw != nil && !ok {
		return fmt.Errorf("field must in Set: required")
	}
	if _, ok := raw["notes"]; raw != nil && !ok {
		return fmt.Errorf("field notes in Set: required")
	}
	if _, ok := raw["order"]; raw != nil && !ok {
		return fmt.Errorf("field order in Set: required")
	}
	if _, ok := raw["rest_s"]; raw != nil && !ok {
		return fmt.Errorf("field rest_s in Set: required")
	}
	if _, ok := raw["rir"]; raw != nil && !ok {
		return fmt.Errorf("field rir in Set: required")
	}
	if _, ok := raw["superset"]; raw != nil && !ok {
		return fmt.Errorf("field superset in Set: required")
	}
	if _, ok := raw["target_reps"]; raw != nil && !ok {
		return fmt.Errorf("field target_reps in Set: required")
	}
	if _, ok := raw["target_weight"]; raw != nil && !ok {
		return fmt.Errorf("field target_weight in Set: required")
	}
	if _, ok := raw["tier"]; raw != nil && !ok {
		return fmt.Errorf("field tier in Set: required")
	}
	type Plain Set
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ActualReps != nil && 0 > *plain.ActualReps {
		return fmt.Errorf("field %s: must be >= %v", "actual_reps", 0)
	}
	if len(plain.Equipment) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "equipment", 1)
	}
	if len(plain.Exercise) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "exercise", 1)
	}
	if matched, _ := regexp.MatchString(`^(W|A|B|C)-[A-Z0-9-]+-(WU[0-9]+|[0-9]+)$`, string(plain.Id)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Id", `^(W|A|B|C)-[A-Z0-9-]+-(WU[0-9]+|[0-9]+)$`)
	}
	if 1 > plain.Order {
		return fmt.Errorf("field %s: must be >= %v", "order", 1)
	}
	if 600 < plain.RestS {
		return fmt.Errorf("field %s: must be <= %v", "rest_s", 600)
	}
	if 0 > plain.RestS {
		return fmt.Errorf("field %s: must be >= %v", "rest_s", 0)
	}
	if plain.Rir != nil && 4 < *plain.Rir {
		return fmt.Errorf("field %s: must be <= %v", "rir", 4)
	}
	if plain.Rir != nil && 0 > *plain.Rir {
		return fmt.Errorf("field %s: must be >= %v", "rir", 0)
	}
	if plain.Superset != nil {
		if matched, _ := regexp.MatchString(`^[A-Z][0-9]+$`, string(*plain.Superset)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Superset", `^[A-Z][0-9]+$`)
		}
	}
	*j = Set(plain)
	return nil
}

type WorkoutV12Json struct {
	// CutOrder corresponds to the JSON schema field "cut_order".
	CutOrder []WorkoutV12JsonCutOrderElem `json:"cut_order" yaml:"cut_order" mapstructure:"cut_order"`

	// Date corresponds to the JSON schema field "date".
	Date types.SerializableDate `json:"date" yaml:"date" mapstructure:"date"`

	// Description corresponds to the JSON schema field "description".
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// DurationMinutes corresponds to the JSON schema field "duration_minutes".
	DurationMinutes int `json:"duration_minutes" yaml:"duration_minutes" mapstructure:"duration_minutes"`

	// Goal corresponds to the JSON schema field "goal".
	Goal string `json:"goal" yaml:"goal" mapstructure:"goal"`

	// Location corresponds to the JSON schema field "location".
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// NotesToUser corresponds to the JSON schema field "notes_to_user".
	NotesToUser *string `json:"notes_to_user" yaml:"notes_to_user" mapstructure:"notes_to_user"`

	// PostWorkout corresponds to the JSON schema field "post_workout".
	PostWorkout PostWorkout `json:"post_workout" yaml:"post_workout" mapstructure:"post_workout"`

	// Sets corresponds to the JSON schema field "sets".
	Sets []Set `json:"sets" yaml:"sets" mapstructure:"sets"`

	// Title corresponds to the JSON schema field "title".
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// Units corresponds to the JSON schema field "units".
	Units WorkoutV12JsonUnits `json:"units" yaml:"units" mapstructure:"units"`

	// Version corresponds to the JSON schema field "version".
	Version float64 `json:"version" yaml:"version" mapstructure:"version"`

	// WorkoutId corresponds to the JSON schema field "workout_id".
	WorkoutId string `json:"workout_id" yaml:"workout_id" mapstructure:"workout_id"`
}

type WorkoutV12JsonCutOrderElem string

const WorkoutV12JsonCutOrderElemB WorkoutV12JsonCutOrderElem = "B"
const WorkoutV12JsonCutOrderElemC WorkoutV12JsonCutOrderElem = "C"

var enumValues_WorkoutV12JsonCutOrderElem = []interface{}{
	"B",
	"C",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorkoutV12JsonCutOrderElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WorkoutV12JsonCutOrderElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WorkoutV12JsonCutOrderElem, v)
	}
	*j = WorkoutV12JsonCutOrderElem(v)
	return nil
}

type WorkoutV12JsonUnits string

const WorkoutV12JsonUnitsKg WorkoutV12JsonUnits = "kg"
const WorkoutV12JsonUnitsLbs WorkoutV12JsonUnits = "lbs"

var enumValues_WorkoutV12JsonUnits = []interface{}{
	"lbs",
	"kg",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorkoutV12JsonUnits) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WorkoutV12JsonUnits {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WorkoutV12JsonUnits, v)
	}
	*j = WorkoutV12JsonUnits(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorkoutV12Json) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["cut_order"]; raw != nil && !ok {
		return fmt.Errorf("field cut_order in WorkoutV12Json: required")
	}
	if _, ok := raw["date"]; raw != nil && !ok {
		return fmt.Errorf("field date in WorkoutV12Json: required")
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in WorkoutV12Json: required")
	}
	if _, ok := raw["duration_minutes"]; raw != nil && !ok {
		return fmt.Errorf("field duration_minutes in WorkoutV12Json: required")
	}
	if _, ok := raw["goal"]; raw != nil && !ok {
		return fmt.Errorf("field goal in WorkoutV12Json: required")
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in WorkoutV12Json: required")
	}
	if _, ok := raw["notes_to_user"]; raw != nil && !ok {
		return fmt.Errorf("field notes_to_user in WorkoutV12Json: required")
	}
	if _, ok := raw["post_workout"]; raw != nil && !ok {
		return fmt.Errorf("field post_workout in WorkoutV12Json: required")
	}
	if _, ok := raw["sets"]; raw != nil && !ok {
		return fmt.Errorf("field sets in WorkoutV12Json: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in WorkoutV12Json: required")
	}
	if _, ok := raw["units"]; raw != nil && !ok {
		return fmt.Errorf("field units in WorkoutV12Json: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in WorkoutV12Json: required")
	}
	if _, ok := raw["workout_id"]; raw != nil && !ok {
		return fmt.Errorf("field workout_id in WorkoutV12Json: required")
	}
	type Plain WorkoutV12Json
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.CutOrder != nil && len(plain.CutOrder) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "cut_order", 1)
	}
	if len(plain.Description) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "description", 1)
	}
	if len(plain.Description) > 2000 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 2000)
	}
	if 180 < plain.DurationMinutes {
		return fmt.Errorf("field %s: must be <= %v", "duration_minutes", 180)
	}
	if 10 > plain.DurationMinutes {
		return fmt.Errorf("field %s: must be >= %v", "duration_minutes", 10)
	}
	if len(plain.Goal) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "goal", 1)
	}
	if len(plain.Location) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "location", 1)
	}
	if plain.Sets != nil && len(plain.Sets) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "sets", 1)
	}
	if len(plain.Title) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "title", 1)
	}
	if len(plain.Title) > 200 {
		return fmt.Errorf("field %s length: must be <= %d", "title", 200)
	}
	if matched, _ := regexp.MatchString(`^[0-9]{4}-[0-9]{2}-[0-9]{2}-[a-z0-9-]+-[0-9]{2}$`, string(plain.WorkoutId)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "WorkoutId", `^[0-9]{4}-[0-9]{2}-[0-9]{2}-[a-z0-9-]+-[0-9]{2}$`)
	}
	*j = WorkoutV12Json(plain)
	return nil
}
