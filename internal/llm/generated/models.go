// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package generated

import "encoding/json"
import "fmt"
import "github.com/atombender/go-jsonschema/pkg/types"
import "reflect"

// Structured plan produced by the Analyzer for a single workout session: metadata,
// session shape, fatigue policy, time budget, available equipment, ordered
// exercise templates, and distilled instruction context.
type AnalyzerV1Json struct {
	// Canonical equipment keys available at the selected location.
	AvailableEquipment []string `json:"available_equipment" yaml:"available_equipment" mapstructure:"available_equipment"`

	// ExercisePlan corresponds to the JSON schema field "exercise_plan".
	ExercisePlan []AnalyzerV1JsonExercisePlanElem `json:"exercise_plan" yaml:"exercise_plan" mapstructure:"exercise_plan"`

	// Session-level adjustments applied when recovery is poor or recent training load
	// is high. The analyzer computes this to make the workout more conservative by
	// altering RIR targets, capping top-set loads, or trimming volume. The generator
	// must honor these values when producing the set plan.
	FatiguePolicy AnalyzerV1JsonFatiguePolicy `json:"fatigue_policy" yaml:"fatigue_policy" mapstructure:"fatigue_policy"`

	// GapFillPolicy corresponds to the JSON schema field "gap_fill_policy".
	GapFillPolicy AnalyzerV1JsonGapFillPolicy `json:"gap_fill_policy" yaml:"gap_fill_policy" mapstructure:"gap_fill_policy"`

	// Distilled view of recent user workouts for anti-repeat and progression logic.
	HistorySummary AnalyzerV1JsonHistorySummary `json:"history_summary" yaml:"history_summary" mapstructure:"history_summary"`

	// Constraints and heuristics distilled from user instructions/history; drives
	// selection, ordering, and execution rules.
	InstructionsContext AnalyzerV1JsonInstructionsContext `json:"instructions_context" yaml:"instructions_context" mapstructure:"instructions_context"`

	// Session metadata used for naming and unit selection.
	Meta AnalyzerV1JsonMeta `json:"meta" yaml:"meta" mapstructure:"meta"`

	// RelevantExercises corresponds to the JSON schema field "relevant_exercises".
	RelevantExercises ExerciseV1 `json:"relevant_exercises" yaml:"relevant_exercises" mapstructure:"relevant_exercises"`

	// Session corresponds to the JSON schema field "session".
	Session AnalyzerV1JsonSession `json:"session" yaml:"session" mapstructure:"session"`

	// TimeBudget corresponds to the JSON schema field "time_budget".
	TimeBudget AnalyzerV1JsonTimeBudget `json:"time_budget" yaml:"time_budget" mapstructure:"time_budget"`
}

type AnalyzerV1JsonExercisePlanElem struct {
	// Canonical equipment key, e.g., 'barbell', 'db_set_5_100', 'cable_station'.
	Equipment string `json:"equipment" yaml:"equipment" mapstructure:"equipment"`

	// Human-readable exercise name (e.g., 'Barbell Bench Press', 'DB Row').
	Exercise string `json:"exercise" yaml:"exercise" mapstructure:"exercise"`

	// Ordered list of preferred implements for performing this exercise pattern, from
	// most to least ideal. Guides the generator in choosing substitutes when the top
	// choice is not available in the current equipment inventory. Example:
	// ["barbell", "dumbbell", "cable", "band", "bodyweight"] for a horizontal push
	// pattern. The generator should select the first available implement in this list
	// and note any substitution in the workout log.
	ImplementPref []string `json:"implement_pref" yaml:"implement_pref" mapstructure:"implement_pref"`

	// Canonical movement pattern classification for this exercise. Used by the
	// generator to preserve training intent during substitutions when specific
	// implements are unavailable. Examples: push_horizontal (bench press, band
	// press), push_vertical (OHP, landmine press), pull_horizontal (row, band row),
	// pull_vertical (pulldown, pull-up), squat_knee (back squat, split squat),
	// hinge_hip (RDL, hip thrust), brace (plank, rollout), rotation (cable rotation,
	// Russian twist), carry (farmer’s carry, suitcase carry). This ensures
	// substitutions remain biomechanically and physiologically equivalent.
	Pattern []string `json:"pattern" yaml:"pattern" mapstructure:"pattern"`

	// Targets corresponds to the JSON schema field "targets".
	Targets AnalyzerV1JsonExercisePlanElemTargets `json:"targets" yaml:"targets" mapstructure:"targets"`

	// Work tiers included for this session, highest priority first. Tier A = must-do,
	// Tier B = nice-to-have, Tier C = stretch goals.
	Tier AnalyzerV1JsonExercisePlanElemTier `json:"tier" yaml:"tier" mapstructure:"tier"`

	// Warmups corresponds to the JSON schema field "warmups".
	Warmups int `json:"warmups" yaml:"warmups" mapstructure:"warmups"`

	// WorkingSets corresponds to the JSON schema field "working_sets".
	WorkingSets int `json:"working_sets" yaml:"working_sets" mapstructure:"working_sets"`
}

type AnalyzerV1JsonExercisePlanElemTargets struct {
	// LoadCap corresponds to the JSON schema field "load_cap".
	LoadCap *float64 `json:"load_cap" yaml:"load_cap" mapstructure:"load_cap"`

	// RepRange corresponds to the JSON schema field "rep_range".
	RepRange string `json:"rep_range" yaml:"rep_range" mapstructure:"rep_range"`

	// Rir corresponds to the JSON schema field "rir".
	Rir *int `json:"rir" yaml:"rir" mapstructure:"rir"`

	// Numeric load in meta.units, or a canonical string for non-numeric loads.
	TargetLoad interface{} `json:"target_load" yaml:"target_load" mapstructure:"target_load"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonExercisePlanElemTargets) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["load_cap"]; raw != nil && !ok {
		return fmt.Errorf("field load_cap in AnalyzerV1JsonExercisePlanElemTargets: required")
	}
	if _, ok := raw["rep_range"]; raw != nil && !ok {
		return fmt.Errorf("field rep_range in AnalyzerV1JsonExercisePlanElemTargets: required")
	}
	if _, ok := raw["rir"]; raw != nil && !ok {
		return fmt.Errorf("field rir in AnalyzerV1JsonExercisePlanElemTargets: required")
	}
	if _, ok := raw["target_load"]; raw != nil && !ok {
		return fmt.Errorf("field target_load in AnalyzerV1JsonExercisePlanElemTargets: required")
	}
	type Plain AnalyzerV1JsonExercisePlanElemTargets
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.RepRange) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "rep_range", 1)
	}
	if plain.Rir != nil && 4 < *plain.Rir {
		return fmt.Errorf("field %s: must be <= %v", "rir", 4)
	}
	if plain.Rir != nil && 0 > *plain.Rir {
		return fmt.Errorf("field %s: must be >= %v", "rir", 0)
	}
	*j = AnalyzerV1JsonExercisePlanElemTargets(plain)
	return nil
}

type AnalyzerV1JsonExercisePlanElemTier string

const AnalyzerV1JsonExercisePlanElemTierA AnalyzerV1JsonExercisePlanElemTier = "A"
const AnalyzerV1JsonExercisePlanElemTierB AnalyzerV1JsonExercisePlanElemTier = "B"
const AnalyzerV1JsonExercisePlanElemTierC AnalyzerV1JsonExercisePlanElemTier = "C"

var enumValues_AnalyzerV1JsonExercisePlanElemTier = []interface{}{
	"A",
	"B",
	"C",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonExercisePlanElemTier) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonExercisePlanElemTier {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonExercisePlanElemTier, v)
	}
	*j = AnalyzerV1JsonExercisePlanElemTier(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonExercisePlanElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["equipment"]; raw != nil && !ok {
		return fmt.Errorf("field equipment in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["exercise"]; raw != nil && !ok {
		return fmt.Errorf("field exercise in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["implement_pref"]; raw != nil && !ok {
		return fmt.Errorf("field implement_pref in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["pattern"]; raw != nil && !ok {
		return fmt.Errorf("field pattern in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["targets"]; raw != nil && !ok {
		return fmt.Errorf("field targets in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["tier"]; raw != nil && !ok {
		return fmt.Errorf("field tier in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["warmups"]; raw != nil && !ok {
		return fmt.Errorf("field warmups in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["working_sets"]; raw != nil && !ok {
		return fmt.Errorf("field working_sets in AnalyzerV1JsonExercisePlanElem: required")
	}
	type Plain AnalyzerV1JsonExercisePlanElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Equipment) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "equipment", 1)
	}
	if len(plain.Exercise) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "exercise", 1)
	}
	if plain.ImplementPref != nil && len(plain.ImplementPref) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "implement_pref", 1)
	}
	if plain.Pattern != nil && len(plain.Pattern) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "pattern", 1)
	}
	if 5 < plain.Warmups {
		return fmt.Errorf("field %s: must be <= %v", "warmups", 5)
	}
	if 1 > plain.Warmups {
		return fmt.Errorf("field %s: must be >= %v", "warmups", 1)
	}
	if 10 < plain.WorkingSets {
		return fmt.Errorf("field %s: must be <= %v", "working_sets", 10)
	}
	if 1 > plain.WorkingSets {
		return fmt.Errorf("field %s: must be >= %v", "working_sets", 1)
	}
	*j = AnalyzerV1JsonExercisePlanElem(plain)
	return nil
}

// Session-level adjustments applied when recovery is poor or recent training load
// is high. The analyzer computes this to make the workout more conservative by
// altering RIR targets, capping top-set loads, or trimming volume. The generator
// must honor these values when producing the set plan.
type AnalyzerV1JsonFatiguePolicy struct {
	// Fractional cap on target load relative to the user’s recent best at the same
	// rep range. Example: 0.95 means cap weights at 95% of recent best. Valid range
	// 0.85–1.0.
	LoadCapPct float64 `json:"load_cap_pct" yaml:"load_cap_pct" mapstructure:"load_cap_pct"`

	// Short human-readable explanation of why the fatigue policy was applied (e.g.,
	// 'High 7-day Relative Effort, low sleep score'). Max length 160 characters.
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Integer increase in the target Reps-in-Reserve (RIR) for all sets. Example: 1
	// means add one extra rep in reserve compared to normal, making the workout
	// easier. Range 0–2.
	RirShift int `json:"rir_shift" yaml:"rir_shift" mapstructure:"rir_shift"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonFatiguePolicy) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["load_cap_pct"]; raw != nil && !ok {
		return fmt.Errorf("field load_cap_pct in AnalyzerV1JsonFatiguePolicy: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in AnalyzerV1JsonFatiguePolicy: required")
	}
	if _, ok := raw["rir_shift"]; raw != nil && !ok {
		return fmt.Errorf("field rir_shift in AnalyzerV1JsonFatiguePolicy: required")
	}
	type Plain AnalyzerV1JsonFatiguePolicy
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if 1 < plain.LoadCapPct {
		return fmt.Errorf("field %s: must be <= %v", "load_cap_pct", 1)
	}
	if 0.85 > plain.LoadCapPct {
		return fmt.Errorf("field %s: must be >= %v", "load_cap_pct", 0.85)
	}
	if 2 < plain.RirShift {
		return fmt.Errorf("field %s: must be <= %v", "rir_shift", 2)
	}
	if 0 > plain.RirShift {
		return fmt.Errorf("field %s: must be >= %v", "rir_shift", 0)
	}
	*j = AnalyzerV1JsonFatiguePolicy(plain)
	return nil
}

type AnalyzerV1JsonGapFillPolicy struct {
	// AllowUnseenMovements corresponds to the JSON schema field
	// "allow_unseen_movements".
	AllowUnseenMovements bool `json:"allow_unseen_movements" yaml:"allow_unseen_movements" mapstructure:"allow_unseen_movements"`

	// MinSetsPerSelectedPattern corresponds to the JSON schema field
	// "min_sets_per_selected_pattern".
	MinSetsPerSelectedPattern *int `json:"min_sets_per_selected_pattern" yaml:"min_sets_per_selected_pattern" mapstructure:"min_sets_per_selected_pattern"`

	// MinWeeklySetsTargets corresponds to the JSON schema field
	// "min_weekly_sets_targets".
	MinWeeklySetsTargets []AnalyzerV1JsonGapFillPolicyMinWeeklySetsTargetsElem `json:"min_weekly_sets_targets" yaml:"min_weekly_sets_targets" mapstructure:"min_weekly_sets_targets"`

	// PersistentPatterns corresponds to the JSON schema field "persistent_patterns".
	PersistentPatterns []string `json:"persistent_patterns" yaml:"persistent_patterns" mapstructure:"persistent_patterns"`

	// TargetPatterns corresponds to the JSON schema field "target_patterns".
	TargetPatterns []string `json:"target_patterns" yaml:"target_patterns" mapstructure:"target_patterns"`
}

type AnalyzerV1JsonGapFillPolicyMinWeeklySetsTargetsElem struct {
	// MinSets corresponds to the JSON schema field "min_sets".
	MinSets int `json:"min_sets" yaml:"min_sets" mapstructure:"min_sets"`

	// Pattern corresponds to the JSON schema field "pattern".
	Pattern string `json:"pattern" yaml:"pattern" mapstructure:"pattern"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonGapFillPolicyMinWeeklySetsTargetsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["min_sets"]; raw != nil && !ok {
		return fmt.Errorf("field min_sets in AnalyzerV1JsonGapFillPolicyMinWeeklySetsTargetsElem: required")
	}
	if _, ok := raw["pattern"]; raw != nil && !ok {
		return fmt.Errorf("field pattern in AnalyzerV1JsonGapFillPolicyMinWeeklySetsTargetsElem: required")
	}
	type Plain AnalyzerV1JsonGapFillPolicyMinWeeklySetsTargetsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AnalyzerV1JsonGapFillPolicyMinWeeklySetsTargetsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonGapFillPolicy) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["allow_unseen_movements"]; raw != nil && !ok {
		return fmt.Errorf("field allow_unseen_movements in AnalyzerV1JsonGapFillPolicy: required")
	}
	if _, ok := raw["min_sets_per_selected_pattern"]; raw != nil && !ok {
		return fmt.Errorf("field min_sets_per_selected_pattern in AnalyzerV1JsonGapFillPolicy: required")
	}
	if _, ok := raw["min_weekly_sets_targets"]; raw != nil && !ok {
		return fmt.Errorf("field min_weekly_sets_targets in AnalyzerV1JsonGapFillPolicy: required")
	}
	if _, ok := raw["persistent_patterns"]; raw != nil && !ok {
		return fmt.Errorf("field persistent_patterns in AnalyzerV1JsonGapFillPolicy: required")
	}
	if _, ok := raw["target_patterns"]; raw != nil && !ok {
		return fmt.Errorf("field target_patterns in AnalyzerV1JsonGapFillPolicy: required")
	}
	type Plain AnalyzerV1JsonGapFillPolicy
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AnalyzerV1JsonGapFillPolicy(plain)
	return nil
}

// Distilled view of recent user workouts for anti-repeat and progression logic.
type AnalyzerV1JsonHistorySummary struct {
	// Movement patterns that should be prioritized today for balanced progression.
	NextPriorityPatterns []string `json:"next_priority_patterns" yaml:"next_priority_patterns" mapstructure:"next_priority_patterns"`

	// Movement patterns to avoid in this session due to high recent frequency.
	PatternsToAvoidToday []string `json:"patterns_to_avoid_today" yaml:"patterns_to_avoid_today" mapstructure:"patterns_to_avoid_today"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonHistorySummary) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["next_priority_patterns"]; raw != nil && !ok {
		return fmt.Errorf("field next_priority_patterns in AnalyzerV1JsonHistorySummary: required")
	}
	if _, ok := raw["patterns_to_avoid_today"]; raw != nil && !ok {
		return fmt.Errorf("field patterns_to_avoid_today in AnalyzerV1JsonHistorySummary: required")
	}
	type Plain AnalyzerV1JsonHistorySummary
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AnalyzerV1JsonHistorySummary(plain)
	return nil
}

// Constraints and heuristics distilled from user instructions/history; drives
// selection, ordering, and execution rules.
type AnalyzerV1JsonInstructionsContext struct {
	// Hard/soft constraints to avoid or emphasize; prefer_single_station is a strong
	// preference (try to minimize station changes).
	Constraints AnalyzerV1JsonInstructionsContextConstraints `json:"constraints" yaml:"constraints" mapstructure:"constraints"`

	// How to assemble the session (format, priorities, and rest policies). Earlier
	// priority_order items are filled first; later ones may be dropped under time
	// constraints.
	ConstructionRules AnalyzerV1JsonInstructionsContextConstructionRules `json:"construction_rules" yaml:"construction_rules" mapstructure:"construction_rules"`

	// ExecutionPrinciples corresponds to the JSON schema field
	// "execution_principles".
	ExecutionPrinciples []string `json:"execution_principles" yaml:"execution_principles" mapstructure:"execution_principles"`

	// Ordered user goals; earlier items take precedence.
	PrimaryGoals []string `json:"primary_goals" yaml:"primary_goals" mapstructure:"primary_goals"`
}

// Hard/soft constraints to avoid or emphasize; prefer_single_station is a strong
// preference (try to minimize station changes).
type AnalyzerV1JsonInstructionsContextConstraints struct {
	// Movements or patterns to avoid (e.g., 'deep knee flexion').
	Avoid []string `json:"avoid" yaml:"avoid" mapstructure:"avoid"`

	// Movements or patterns to emphasize (e.g., 'horizontal pull').
	Encourage []string `json:"encourage" yaml:"encourage" mapstructure:"encourage"`

	// If true, strongly prefer plans that minimize moving between stations; null = no
	// preference.
	PreferSingleStation *bool `json:"prefer_single_station" yaml:"prefer_single_station" mapstructure:"prefer_single_station"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonInstructionsContextConstraints) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["avoid"]; raw != nil && !ok {
		return fmt.Errorf("field avoid in AnalyzerV1JsonInstructionsContextConstraints: required")
	}
	if _, ok := raw["encourage"]; raw != nil && !ok {
		return fmt.Errorf("field encourage in AnalyzerV1JsonInstructionsContextConstraints: required")
	}
	if _, ok := raw["prefer_single_station"]; raw != nil && !ok {
		return fmt.Errorf("field prefer_single_station in AnalyzerV1JsonInstructionsContextConstraints: required")
	}
	type Plain AnalyzerV1JsonInstructionsContextConstraints
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AnalyzerV1JsonInstructionsContextConstraints(plain)
	return nil
}

// How to assemble the session (format, priorities, and rest policies). Earlier
// priority_order items are filled first; later ones may be dropped under time
// constraints.
type AnalyzerV1JsonInstructionsContextConstructionRules struct {
	// Format corresponds to the JSON schema field "format".
	Format AnalyzerV1JsonInstructionsContextConstructionRulesFormat `json:"format" yaml:"format" mapstructure:"format"`

	// PriorityOrder corresponds to the JSON schema field "priority_order".
	PriorityOrder []AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem `json:"priority_order" yaml:"priority_order" mapstructure:"priority_order"`

	// Target rest between paired/clustered sets; null if not applicable for chosen
	// format.
	RestBetweenSupersetsSec *int `json:"rest_between_supersets_sec" yaml:"rest_between_supersets_sec" mapstructure:"rest_between_supersets_sec"`
}

type AnalyzerV1JsonInstructionsContextConstructionRulesFormat string

const AnalyzerV1JsonInstructionsContextConstructionRulesFormatGiantSets AnalyzerV1JsonInstructionsContextConstructionRulesFormat = "giant_sets"
const AnalyzerV1JsonInstructionsContextConstructionRulesFormatStraightSets AnalyzerV1JsonInstructionsContextConstructionRulesFormat = "straight_sets"
const AnalyzerV1JsonInstructionsContextConstructionRulesFormatSupersets AnalyzerV1JsonInstructionsContextConstructionRulesFormat = "supersets"

var enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesFormat = []interface{}{
	"supersets",
	"giant_sets",
	"straight_sets",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonInstructionsContextConstructionRulesFormat) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesFormat {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesFormat, v)
	}
	*j = AnalyzerV1JsonInstructionsContextConstructionRulesFormat(v)
	return nil
}

type AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem string

const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemAccessoryPull AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "accessory_pull"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemAccessoryPush AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "accessory_push"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemAntiExtensionCore AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "anti_extension_core"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemAntiLateralCore AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "anti_lateral_core"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemArmAccessory AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "arm_accessory"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemBigCompound AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "big_compound"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemConditioning AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "conditioning"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemCoreStability AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "core_stability"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemGripForearm AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "grip_forearm"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemHypertrophyCompound AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "hypertrophy_compound"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemIsolationFinishers AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "isolation_finishers"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemMetabolicFinishers AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "metabolic_finishers"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemMobilityFlexibility AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "mobility_flexibility"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemPosteriorChain AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "posterior_chain"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemPrehabRehab AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "prehab_rehab"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemRotationalCore AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "rotational_core"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemSecondaryCompound AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "secondary_compound"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemShoulderAccessory AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "shoulder_accessory"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemSingleLegUnilateral AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "single_leg_unilateral"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemWarmupActivation AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "warmup_activation"

var enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = []interface{}{
	"warmup_activation",
	"big_compound",
	"secondary_compound",
	"hypertrophy_compound",
	"accessory_push",
	"accessory_pull",
	"posterior_chain",
	"single_leg_unilateral",
	"shoulder_accessory",
	"arm_accessory",
	"core_stability",
	"rotational_core",
	"anti_extension_core",
	"anti_lateral_core",
	"isolation_finishers",
	"conditioning",
	"grip_forearm",
	"prehab_rehab",
	"mobility_flexibility",
	"metabolic_finishers",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem, v)
	}
	*j = AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonInstructionsContextConstructionRules) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["format"]; raw != nil && !ok {
		return fmt.Errorf("field format in AnalyzerV1JsonInstructionsContextConstructionRules: required")
	}
	if _, ok := raw["priority_order"]; raw != nil && !ok {
		return fmt.Errorf("field priority_order in AnalyzerV1JsonInstructionsContextConstructionRules: required")
	}
	if _, ok := raw["rest_between_supersets_sec"]; raw != nil && !ok {
		return fmt.Errorf("field rest_between_supersets_sec in AnalyzerV1JsonInstructionsContextConstructionRules: required")
	}
	type Plain AnalyzerV1JsonInstructionsContextConstructionRules
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.PriorityOrder != nil && len(plain.PriorityOrder) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "priority_order", 1)
	}
	if plain.RestBetweenSupersetsSec != nil && 300 < *plain.RestBetweenSupersetsSec {
		return fmt.Errorf("field %s: must be <= %v", "rest_between_supersets_sec", 300)
	}
	if plain.RestBetweenSupersetsSec != nil && 0 > *plain.RestBetweenSupersetsSec {
		return fmt.Errorf("field %s: must be >= %v", "rest_between_supersets_sec", 0)
	}
	*j = AnalyzerV1JsonInstructionsContextConstructionRules(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonInstructionsContext) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["constraints"]; raw != nil && !ok {
		return fmt.Errorf("field constraints in AnalyzerV1JsonInstructionsContext: required")
	}
	if _, ok := raw["construction_rules"]; raw != nil && !ok {
		return fmt.Errorf("field construction_rules in AnalyzerV1JsonInstructionsContext: required")
	}
	if _, ok := raw["execution_principles"]; raw != nil && !ok {
		return fmt.Errorf("field execution_principles in AnalyzerV1JsonInstructionsContext: required")
	}
	if _, ok := raw["primary_goals"]; raw != nil && !ok {
		return fmt.Errorf("field primary_goals in AnalyzerV1JsonInstructionsContext: required")
	}
	type Plain AnalyzerV1JsonInstructionsContext
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ExecutionPrinciples != nil && len(plain.ExecutionPrinciples) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "execution_principles", 1)
	}
	if plain.PrimaryGoals != nil && len(plain.PrimaryGoals) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "primary_goals", 1)
	}
	*j = AnalyzerV1JsonInstructionsContext(plain)
	return nil
}

// Session metadata used for naming and unit selection.
type AnalyzerV1JsonMeta struct {
	// Date corresponds to the JSON schema field "date".
	Date DateV1 `json:"date" yaml:"date" mapstructure:"date"`

	// Total planned session time including warm-ups and rest (minutes).
	DurationMinutes int `json:"duration_minutes" yaml:"duration_minutes" mapstructure:"duration_minutes"`

	// Primary user goal for this session (free text).
	Goal string `json:"goal" yaml:"goal" mapstructure:"goal"`

	// Free-form location (e.g., 'home', 'gym:golds', 'hotel:hyatt').
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// Whether the generator should form supersets and how aggressively.
	SupersetPolicy AnalyzerV1JsonMetaSupersetPolicy `json:"superset_policy" yaml:"superset_policy" mapstructure:"superset_policy"`

	// SupersetPreferences corresponds to the JSON schema field
	// "superset_preferences".
	SupersetPreferences AnalyzerV1JsonMetaSupersetPreferences `json:"superset_preferences" yaml:"superset_preferences" mapstructure:"superset_preferences"`

	// Weight units used for target_load in this plan.
	Units AnalyzerV1JsonMetaUnits `json:"units" yaml:"units" mapstructure:"units"`
}

type AnalyzerV1JsonMetaSupersetPolicy string

const AnalyzerV1JsonMetaSupersetPolicyAutoWhenTimeLimited AnalyzerV1JsonMetaSupersetPolicy = "auto_when_time_limited"
const AnalyzerV1JsonMetaSupersetPolicyGiantSetsOk AnalyzerV1JsonMetaSupersetPolicy = "giant_sets_ok"
const AnalyzerV1JsonMetaSupersetPolicyNone AnalyzerV1JsonMetaSupersetPolicy = "none"
const AnalyzerV1JsonMetaSupersetPolicyPairsOk AnalyzerV1JsonMetaSupersetPolicy = "pairs_ok"
const AnalyzerV1JsonMetaSupersetPolicyPreferred AnalyzerV1JsonMetaSupersetPolicy = "preferred"
const AnalyzerV1JsonMetaSupersetPolicyRequired AnalyzerV1JsonMetaSupersetPolicy = "required"

var enumValues_AnalyzerV1JsonMetaSupersetPolicy = []interface{}{
	"none",
	"pairs_ok",
	"preferred",
	"required",
	"giant_sets_ok",
	"auto_when_time_limited",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonMetaSupersetPolicy) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonMetaSupersetPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonMetaSupersetPolicy, v)
	}
	*j = AnalyzerV1JsonMetaSupersetPolicy(v)
	return nil
}

type AnalyzerV1JsonMetaSupersetPreferences struct {
	// Do not superset Tier A barbell compounds.
	AvoidHeavyCompounds bool `json:"avoid_heavy_compounds" yaml:"avoid_heavy_compounds" mapstructure:"avoid_heavy_compounds"`

	// Skip metabolic pairings if cardio is scheduled soon.
	AvoidHrSpikePairings bool `json:"avoid_hr_spike_pairings" yaml:"avoid_hr_spike_pairings" mapstructure:"avoid_hr_spike_pairings"`

	// Avoid pairings that require the same rack/cable at once.
	AvoidSameImplementConflicts bool `json:"avoid_same_implement_conflicts" yaml:"avoid_same_implement_conflicts" mapstructure:"avoid_same_implement_conflicts"`

	// Favor push+pull or hinge+core pairings over same-muscle pairings.
	PreferNonCompeting bool `json:"prefer_non_competing" yaml:"prefer_non_competing" mapstructure:"prefer_non_competing"`

	// Soft target; generator can deviate for time/equipment.
	TargetSupersetCount int `json:"target_superset_count" yaml:"target_superset_count" mapstructure:"target_superset_count"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonMetaSupersetPreferences) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["target_superset_count"]; raw != nil && !ok {
		return fmt.Errorf("field target_superset_count in AnalyzerV1JsonMetaSupersetPreferences: required")
	}
	type Plain AnalyzerV1JsonMetaSupersetPreferences
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["avoid_heavy_compounds"]; !ok || v == nil {
		plain.AvoidHeavyCompounds = false
	}
	if v, ok := raw["avoid_hr_spike_pairings"]; !ok || v == nil {
		plain.AvoidHrSpikePairings = false
	}
	if v, ok := raw["avoid_same_implement_conflicts"]; !ok || v == nil {
		plain.AvoidSameImplementConflicts = false
	}
	if v, ok := raw["prefer_non_competing"]; !ok || v == nil {
		plain.PreferNonCompeting = true
	}
	if 6 < plain.TargetSupersetCount {
		return fmt.Errorf("field %s: must be <= %v", "target_superset_count", 6)
	}
	if 0 > plain.TargetSupersetCount {
		return fmt.Errorf("field %s: must be >= %v", "target_superset_count", 0)
	}
	*j = AnalyzerV1JsonMetaSupersetPreferences(plain)
	return nil
}

type AnalyzerV1JsonMetaUnits string

const AnalyzerV1JsonMetaUnitsKg AnalyzerV1JsonMetaUnits = "kg"
const AnalyzerV1JsonMetaUnitsLbs AnalyzerV1JsonMetaUnits = "lbs"

var enumValues_AnalyzerV1JsonMetaUnits = []interface{}{
	"lbs",
	"kg",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonMetaUnits) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonMetaUnits {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonMetaUnits, v)
	}
	*j = AnalyzerV1JsonMetaUnits(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonMeta) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["date"]; raw != nil && !ok {
		return fmt.Errorf("field date in AnalyzerV1JsonMeta: required")
	}
	if _, ok := raw["duration_minutes"]; raw != nil && !ok {
		return fmt.Errorf("field duration_minutes in AnalyzerV1JsonMeta: required")
	}
	if _, ok := raw["goal"]; raw != nil && !ok {
		return fmt.Errorf("field goal in AnalyzerV1JsonMeta: required")
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in AnalyzerV1JsonMeta: required")
	}
	if _, ok := raw["superset_preferences"]; raw != nil && !ok {
		return fmt.Errorf("field superset_preferences in AnalyzerV1JsonMeta: required")
	}
	if _, ok := raw["units"]; raw != nil && !ok {
		return fmt.Errorf("field units in AnalyzerV1JsonMeta: required")
	}
	type Plain AnalyzerV1JsonMeta
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if 180 < plain.DurationMinutes {
		return fmt.Errorf("field %s: must be <= %v", "duration_minutes", 180)
	}
	if 10 > plain.DurationMinutes {
		return fmt.Errorf("field %s: must be >= %v", "duration_minutes", 10)
	}
	if len(plain.Goal) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "goal", 1)
	}
	if len(plain.Location) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "location", 1)
	}
	if v, ok := raw["superset_policy"]; !ok || v == nil {
		plain.SupersetPolicy = "pairs_ok"
	}
	*j = AnalyzerV1JsonMeta(plain)
	return nil
}

type AnalyzerV1JsonSession struct {
	// If time runs short, drop tiers in this order; first listed is cut first (least
	// protected). Should be a permutation of the tiers present.
	CutOrder []AnalyzerV1JsonSessionCutOrderElem `json:"cut_order" yaml:"cut_order" mapstructure:"cut_order"`

	// Work tiers included for this session, highest priority first. Tier A = must-do,
	// Tier B = nice-to-have, Tier C = stretch goals.
	Tiers []AnalyzerV1JsonSessionTiersElem `json:"tiers" yaml:"tiers" mapstructure:"tiers"`

	// Primary identity of today’s session. This drives exercise pools and defaults
	// (rep ranges, rest, emphasis).
	Type AnalyzerV1JsonSessionType `json:"type" yaml:"type" mapstructure:"type"`

	// How to warm up before Tier A (and optionally others). Defaults applied if
	// omitted.
	WarmupPolicy AnalyzerV1JsonSessionWarmupPolicy `json:"warmup_policy" yaml:"warmup_policy" mapstructure:"warmup_policy"`
}

type AnalyzerV1JsonSessionCutOrderElem string

const AnalyzerV1JsonSessionCutOrderElemB AnalyzerV1JsonSessionCutOrderElem = "B"
const AnalyzerV1JsonSessionCutOrderElemC AnalyzerV1JsonSessionCutOrderElem = "C"

var enumValues_AnalyzerV1JsonSessionCutOrderElem = []interface{}{
	"B",
	"C",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonSessionCutOrderElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonSessionCutOrderElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonSessionCutOrderElem, v)
	}
	*j = AnalyzerV1JsonSessionCutOrderElem(v)
	return nil
}

type AnalyzerV1JsonSessionTiersElem string

const AnalyzerV1JsonSessionTiersElemA AnalyzerV1JsonSessionTiersElem = "A"
const AnalyzerV1JsonSessionTiersElemB AnalyzerV1JsonSessionTiersElem = "B"
const AnalyzerV1JsonSessionTiersElemC AnalyzerV1JsonSessionTiersElem = "C"

var enumValues_AnalyzerV1JsonSessionTiersElem = []interface{}{
	"A",
	"B",
	"C",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonSessionTiersElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonSessionTiersElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonSessionTiersElem, v)
	}
	*j = AnalyzerV1JsonSessionTiersElem(v)
	return nil
}

type AnalyzerV1JsonSessionType string

const AnalyzerV1JsonSessionTypeArmsCore AnalyzerV1JsonSessionType = "arms_core"
const AnalyzerV1JsonSessionTypeConditioningEmphasis AnalyzerV1JsonSessionType = "conditioning_emphasis"
const AnalyzerV1JsonSessionTypeCustom AnalyzerV1JsonSessionType = "custom"
const AnalyzerV1JsonSessionTypeFatLoss AnalyzerV1JsonSessionType = "fat_loss"
const AnalyzerV1JsonSessionTypeFullBody AnalyzerV1JsonSessionType = "full_body"
const AnalyzerV1JsonSessionTypeGlutesCore AnalyzerV1JsonSessionType = "glutes_core"
const AnalyzerV1JsonSessionTypeHypertrophy AnalyzerV1JsonSessionType = "hypertrophy"
const AnalyzerV1JsonSessionTypeLower AnalyzerV1JsonSessionType = "lower"
const AnalyzerV1JsonSessionTypeLowerHinge AnalyzerV1JsonSessionType = "lower_hinge"
const AnalyzerV1JsonSessionTypeLowerQuad AnalyzerV1JsonSessionType = "lower_quad"
const AnalyzerV1JsonSessionTypeMaintenance AnalyzerV1JsonSessionType = "maintenance"
const AnalyzerV1JsonSessionTypePosteriorChain AnalyzerV1JsonSessionType = "posterior_chain"
const AnalyzerV1JsonSessionTypePower AnalyzerV1JsonSessionType = "power"
const AnalyzerV1JsonSessionTypePull AnalyzerV1JsonSessionType = "pull"
const AnalyzerV1JsonSessionTypePush AnalyzerV1JsonSessionType = "push"
const AnalyzerV1JsonSessionTypeStrength AnalyzerV1JsonSessionType = "strength"
const AnalyzerV1JsonSessionTypeUpper AnalyzerV1JsonSessionType = "upper"
const AnalyzerV1JsonSessionTypeUpperPull AnalyzerV1JsonSessionType = "upper_pull"
const AnalyzerV1JsonSessionTypeUpperPush AnalyzerV1JsonSessionType = "upper_push"

var enumValues_AnalyzerV1JsonSessionType = []interface{}{
	"hypertrophy",
	"strength",
	"power",
	"maintenance",
	"fat_loss",
	"upper",
	"lower",
	"push",
	"pull",
	"full_body",
	"posterior_chain",
	"glutes_core",
	"arms_core",
	"upper_push",
	"upper_pull",
	"lower_quad",
	"lower_hinge",
	"conditioning_emphasis",
	"custom",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonSessionType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonSessionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonSessionType, v)
	}
	*j = AnalyzerV1JsonSessionType(v)
	return nil
}

// How to warm up before Tier A (and optionally others). Defaults applied if
// omitted.
type AnalyzerV1JsonSessionWarmupPolicy struct {
	// GeneralMinutes corresponds to the JSON schema field "general_minutes".
	GeneralMinutes int `json:"general_minutes" yaml:"general_minutes" mapstructure:"general_minutes"`

	// 5–8 min light cardio/mobility.
	IncludeGeneral bool `json:"include_general" yaml:"include_general" mapstructure:"include_general"`

	// Progressive ramp sets before first Tier A compound.
	IncludeSpecific bool `json:"include_specific" yaml:"include_specific" mapstructure:"include_specific"`

	// SpecificRampSets corresponds to the JSON schema field "specific_ramp_sets".
	SpecificRampSets int `json:"specific_ramp_sets" yaml:"specific_ramp_sets" mapstructure:"specific_ramp_sets"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonSessionWarmupPolicy) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain AnalyzerV1JsonSessionWarmupPolicy
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["general_minutes"]; !ok || v == nil {
		plain.GeneralMinutes = 5.0
	}
	if 15 < plain.GeneralMinutes {
		return fmt.Errorf("field %s: must be <= %v", "general_minutes", 15)
	}
	if 0 > plain.GeneralMinutes {
		return fmt.Errorf("field %s: must be >= %v", "general_minutes", 0)
	}
	if v, ok := raw["include_general"]; !ok || v == nil {
		plain.IncludeGeneral = true
	}
	if v, ok := raw["include_specific"]; !ok || v == nil {
		plain.IncludeSpecific = true
	}
	if v, ok := raw["specific_ramp_sets"]; !ok || v == nil {
		plain.SpecificRampSets = 2.0
	}
	if 5 < plain.SpecificRampSets {
		return fmt.Errorf("field %s: must be <= %v", "specific_ramp_sets", 5)
	}
	if 0 > plain.SpecificRampSets {
		return fmt.Errorf("field %s: must be >= %v", "specific_ramp_sets", 0)
	}
	*j = AnalyzerV1JsonSessionWarmupPolicy(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonSession) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["cut_order"]; raw != nil && !ok {
		return fmt.Errorf("field cut_order in AnalyzerV1JsonSession: required")
	}
	if _, ok := raw["tiers"]; raw != nil && !ok {
		return fmt.Errorf("field tiers in AnalyzerV1JsonSession: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AnalyzerV1JsonSession: required")
	}
	if _, ok := raw["warmup_policy"]; raw != nil && !ok {
		return fmt.Errorf("field warmup_policy in AnalyzerV1JsonSession: required")
	}
	type Plain AnalyzerV1JsonSession
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.CutOrder != nil && len(plain.CutOrder) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "cut_order", 1)
	}
	if plain.Tiers != nil && len(plain.Tiers) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "tiers", 1)
	}
	*j = AnalyzerV1JsonSession(plain)
	return nil
}

type AnalyzerV1JsonTimeBudget struct {
	// EstimatedMinutesTotal corresponds to the JSON schema field
	// "estimated_minutes_total".
	EstimatedMinutesTotal *int `json:"estimated_minutes_total" yaml:"estimated_minutes_total" mapstructure:"estimated_minutes_total"`

	// TargetSetCount corresponds to the JSON schema field "target_set_count".
	TargetSetCount int `json:"target_set_count" yaml:"target_set_count" mapstructure:"target_set_count"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonTimeBudget) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["estimated_minutes_total"]; raw != nil && !ok {
		return fmt.Errorf("field estimated_minutes_total in AnalyzerV1JsonTimeBudget: required")
	}
	if _, ok := raw["target_set_count"]; raw != nil && !ok {
		return fmt.Errorf("field target_set_count in AnalyzerV1JsonTimeBudget: required")
	}
	type Plain AnalyzerV1JsonTimeBudget
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EstimatedMinutesTotal != nil && 180 < *plain.EstimatedMinutesTotal {
		return fmt.Errorf("field %s: must be <= %v", "estimated_minutes_total", 180)
	}
	if plain.EstimatedMinutesTotal != nil && 10 > *plain.EstimatedMinutesTotal {
		return fmt.Errorf("field %s: must be >= %v", "estimated_minutes_total", 10)
	}
	if 50 < plain.TargetSetCount {
		return fmt.Errorf("field %s: must be <= %v", "target_set_count", 50)
	}
	if 1 > plain.TargetSetCount {
		return fmt.Errorf("field %s: must be >= %v", "target_set_count", 1)
	}
	*j = AnalyzerV1JsonTimeBudget(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1Json) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["available_equipment"]; raw != nil && !ok {
		return fmt.Errorf("field available_equipment in AnalyzerV1Json: required")
	}
	if _, ok := raw["exercise_plan"]; raw != nil && !ok {
		return fmt.Errorf("field exercise_plan in AnalyzerV1Json: required")
	}
	if _, ok := raw["fatigue_policy"]; raw != nil && !ok {
		return fmt.Errorf("field fatigue_policy in AnalyzerV1Json: required")
	}
	if _, ok := raw["gap_fill_policy"]; raw != nil && !ok {
		return fmt.Errorf("field gap_fill_policy in AnalyzerV1Json: required")
	}
	if _, ok := raw["history_summary"]; raw != nil && !ok {
		return fmt.Errorf("field history_summary in AnalyzerV1Json: required")
	}
	if _, ok := raw["instructions_context"]; raw != nil && !ok {
		return fmt.Errorf("field instructions_context in AnalyzerV1Json: required")
	}
	if _, ok := raw["meta"]; raw != nil && !ok {
		return fmt.Errorf("field meta in AnalyzerV1Json: required")
	}
	if _, ok := raw["relevant_exercises"]; raw != nil && !ok {
		return fmt.Errorf("field relevant_exercises in AnalyzerV1Json: required")
	}
	if _, ok := raw["session"]; raw != nil && !ok {
		return fmt.Errorf("field session in AnalyzerV1Json: required")
	}
	if _, ok := raw["time_budget"]; raw != nil && !ok {
		return fmt.Errorf("field time_budget in AnalyzerV1Json: required")
	}
	type Plain AnalyzerV1Json
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AvailableEquipment != nil && len(plain.AvailableEquipment) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "available_equipment", 1)
	}
	if plain.ExercisePlan != nil && len(plain.ExercisePlan) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "exercise_plan", 1)
	}
	*j = AnalyzerV1Json(plain)
	return nil
}

// date in YYYY-MM-DD.
type DateV1 types.SerializableDate

// Structured exercise reference.
type ExerciseV1 []struct {
	// Canonical equipment keys. If any required item is not listed, include
	// "eq_other" and list free-text names in equipment_other; set equipment_other to
	// null otherwise.
	Equipment []ExerciseV1ElemEquipmentElem `json:"equipment" yaml:"equipment" mapstructure:"equipment"`

	// Short notes about equipment constraints or specifics.
	EquipmentNotes *string `json:"equipment_notes" yaml:"equipment_notes" mapstructure:"equipment_notes"`

	// Free-text equipment when using eq_other. Set to null otherwise. Note that
	// Bodyweight exercises should not use eq_other, rather use eq_bodyweight.
	EquipmentOther []string `json:"equipment_other" yaml:"equipment_other" mapstructure:"equipment_other"`

	// Free-form notes about the exercise; set to null if none.
	Notes *string `json:"notes" yaml:"notes" mapstructure:"notes"`

	// Movement pattern classification(s) for this exercise.
	Pattern []ExerciseV1ElemPatternElem `json:"pattern" yaml:"pattern" mapstructure:"pattern"`

	// Most recent best performance for this exercise; null if unknown.
	RecentBest *ExerciseV1ElemRecentBest `json:"recent_best" yaml:"recent_best" mapstructure:"recent_best"`

	// Canonical exercise slug, kebab-case (e.g., "barbell-bench-press").
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Priority tier: A = must-do, B = nice-to-have, C = stretch goals.
	TierHint ExerciseV1ElemTierHint `json:"tier_hint" yaml:"tier_hint" mapstructure:"tier_hint"`
}

type ExerciseV1ElemEquipmentElem string

const ExerciseV1ElemEquipmentElemEqAdjustableBench ExerciseV1ElemEquipmentElem = "eq_adjustable_bench"
const ExerciseV1ElemEquipmentElemEqAirBike ExerciseV1ElemEquipmentElem = "eq_air_bike"
const ExerciseV1ElemEquipmentElemEqAssistedPullup ExerciseV1ElemEquipmentElem = "eq_assisted_pullup"
const ExerciseV1ElemEquipmentElemEqBandsFull ExerciseV1ElemEquipmentElem = "eq_bands_full"
const ExerciseV1ElemEquipmentElemEqBandsLightMedium ExerciseV1ElemEquipmentElem = "eq_bands_light_medium"
const ExerciseV1ElemEquipmentElemEqBarbell ExerciseV1ElemEquipmentElem = "eq_barbell"
const ExerciseV1ElemEquipmentElemEqBodyweight ExerciseV1ElemEquipmentElem = "eq_bodyweight"
const ExerciseV1ElemEquipmentElemEqCableAttachmentsBasic ExerciseV1ElemEquipmentElem = "eq_cable_attachments_basic"
const ExerciseV1ElemEquipmentElemEqCableAttachmentsFull ExerciseV1ElemEquipmentElem = "eq_cable_attachments_full"
const ExerciseV1ElemEquipmentElemEqCableMachineDualStack ExerciseV1ElemEquipmentElem = "eq_cable_machine_dual_stack"
const ExerciseV1ElemEquipmentElemEqCableMachineSingleStack ExerciseV1ElemEquipmentElem = "eq_cable_machine_single_stack"
const ExerciseV1ElemEquipmentElemEqDipBars ExerciseV1ElemEquipmentElem = "eq_dip_bars"
const ExerciseV1ElemEquipmentElemEqDumbbellsSet550 ExerciseV1ElemEquipmentElem = "eq_dumbbells_set_5-50"
const ExerciseV1ElemEquipmentElemEqDumbbellsSet55100 ExerciseV1ElemEquipmentElem = "eq_dumbbells_set_55-100"
const ExerciseV1ElemEquipmentElemEqElliptical ExerciseV1ElemEquipmentElem = "eq_elliptical"
const ExerciseV1ElemEquipmentElemEqFlatBench ExerciseV1ElemEquipmentElem = "eq_flat_bench"
const ExerciseV1ElemEquipmentElemEqHipThrustBenchOrPad ExerciseV1ElemEquipmentElem = "eq_hip_thrust_bench_or_pad"
const ExerciseV1ElemEquipmentElemEqKettlebellsSet4070 ExerciseV1ElemEquipmentElem = "eq_kettlebells_set_40-70"
const ExerciseV1ElemEquipmentElemEqKettlebellsSet535 ExerciseV1ElemEquipmentElem = "eq_kettlebells_set_5-35"
const ExerciseV1ElemEquipmentElemEqLatPulldown ExerciseV1ElemEquipmentElem = "eq_lat_pulldown"
const ExerciseV1ElemEquipmentElemEqMatArea ExerciseV1ElemEquipmentElem = "eq_mat_area"
const ExerciseV1ElemEquipmentElemEqOlympicBarbellMens20Kg ExerciseV1ElemEquipmentElem = "eq_olympic_barbell_mens_20kg"
const ExerciseV1ElemEquipmentElemEqOlympicBarbellWomens15Kg ExerciseV1ElemEquipmentElem = "eq_olympic_barbell_womens_15kg"
const ExerciseV1ElemEquipmentElemEqOther ExerciseV1ElemEquipmentElem = "eq_other"
const ExerciseV1ElemEquipmentElemEqPlyoBox ExerciseV1ElemEquipmentElem = "eq_plyo_box"
const ExerciseV1ElemEquipmentElemEqPowerRack ExerciseV1ElemEquipmentElem = "eq_power_rack"
const ExerciseV1ElemEquipmentElemEqPullupBar ExerciseV1ElemEquipmentElem = "eq_pullup_bar"
const ExerciseV1ElemEquipmentElemEqRower ExerciseV1ElemEquipmentElem = "eq_rower"
const ExerciseV1ElemEquipmentElemEqSeatedRow ExerciseV1ElemEquipmentElem = "eq_seated_row"
const ExerciseV1ElemEquipmentElemEqSledAndTurf ExerciseV1ElemEquipmentElem = "eq_sled_and_turf"
const ExerciseV1ElemEquipmentElemEqSmithMachine ExerciseV1ElemEquipmentElem = "eq_smith_machine"
const ExerciseV1ElemEquipmentElemEqSquatStand ExerciseV1ElemEquipmentElem = "eq_squat_stand"
const ExerciseV1ElemEquipmentElemEqStairClimber ExerciseV1ElemEquipmentElem = "eq_stair_climber"
const ExerciseV1ElemEquipmentElemEqStationaryBike ExerciseV1ElemEquipmentElem = "eq_stationary_bike"
const ExerciseV1ElemEquipmentElemEqStepPlatform ExerciseV1ElemEquipmentElem = "eq_step_platform"
const ExerciseV1ElemEquipmentElemEqTreadmill ExerciseV1ElemEquipmentElem = "eq_treadmill"
const ExerciseV1ElemEquipmentElemEqWeightPlatesBumper ExerciseV1ElemEquipmentElem = "eq_weight_plates_bumper"
const ExerciseV1ElemEquipmentElemEqWeightPlatesMicro ExerciseV1ElemEquipmentElem = "eq_weight_plates_micro"
const ExerciseV1ElemEquipmentElemEqWeightPlatesStandard ExerciseV1ElemEquipmentElem = "eq_weight_plates_standard"

var enumValues_ExerciseV1ElemEquipmentElem = []interface{}{
	"eq_bodyweight",
	"eq_dumbbells_set_5-50",
	"eq_dumbbells_set_55-100",
	"eq_kettlebells_set_5-35",
	"eq_kettlebells_set_40-70",
	"eq_barbell",
	"eq_olympic_barbell_mens_20kg",
	"eq_olympic_barbell_womens_15kg",
	"eq_weight_plates_standard",
	"eq_weight_plates_bumper",
	"eq_weight_plates_micro",
	"eq_flat_bench",
	"eq_adjustable_bench",
	"eq_hip_thrust_bench_or_pad",
	"eq_step_platform",
	"eq_plyo_box",
	"eq_power_rack",
	"eq_squat_stand",
	"eq_smith_machine",
	"eq_cable_machine_single_stack",
	"eq_cable_machine_dual_stack",
	"eq_lat_pulldown",
	"eq_seated_row",
	"eq_cable_attachments_basic",
	"eq_cable_attachments_full",
	"eq_bands_light_medium",
	"eq_bands_full",
	"eq_pullup_bar",
	"eq_assisted_pullup",
	"eq_dip_bars",
	"eq_mat_area",
	"eq_treadmill",
	"eq_stationary_bike",
	"eq_air_bike",
	"eq_elliptical",
	"eq_rower",
	"eq_stair_climber",
	"eq_sled_and_turf",
	"eq_other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExerciseV1ElemEquipmentElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExerciseV1ElemEquipmentElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExerciseV1ElemEquipmentElem, v)
	}
	*j = ExerciseV1ElemEquipmentElem(v)
	return nil
}

type ExerciseV1ElemPatternElem string

const ExerciseV1ElemPatternElemArmAccessory ExerciseV1ElemPatternElem = "arm_accessory"
const ExerciseV1ElemPatternElemBrace ExerciseV1ElemPatternElem = "brace"
const ExerciseV1ElemPatternElemCarry ExerciseV1ElemPatternElem = "carry"
const ExerciseV1ElemPatternElemConditioning ExerciseV1ElemPatternElem = "conditioning"
const ExerciseV1ElemPatternElemCoreAntiExtension ExerciseV1ElemPatternElem = "core_anti_extension"
const ExerciseV1ElemPatternElemCoreAntiRotation ExerciseV1ElemPatternElem = "core_anti_rotation"
const ExerciseV1ElemPatternElemCoreFlexion ExerciseV1ElemPatternElem = "core_flexion"
const ExerciseV1ElemPatternElemCoreRotation ExerciseV1ElemPatternElem = "core_rotation"
const ExerciseV1ElemPatternElemHingeHip ExerciseV1ElemPatternElem = "hinge_hip"
const ExerciseV1ElemPatternElemIsolationBiceps ExerciseV1ElemPatternElem = "isolation_biceps"
const ExerciseV1ElemPatternElemIsolationCalves ExerciseV1ElemPatternElem = "isolation_calves"
const ExerciseV1ElemPatternElemIsolationDelts ExerciseV1ElemPatternElem = "isolation_delts"
const ExerciseV1ElemPatternElemIsolationHamstrings ExerciseV1ElemPatternElem = "isolation_hamstrings"
const ExerciseV1ElemPatternElemIsolationQuads ExerciseV1ElemPatternElem = "isolation_quads"
const ExerciseV1ElemPatternElemIsolationTriceps ExerciseV1ElemPatternElem = "isolation_triceps"
const ExerciseV1ElemPatternElemLegAccessory ExerciseV1ElemPatternElem = "leg_accessory"
const ExerciseV1ElemPatternElemPullHorizontal ExerciseV1ElemPatternElem = "pull_horizontal"
const ExerciseV1ElemPatternElemPullVertical ExerciseV1ElemPatternElem = "pull_vertical"
const ExerciseV1ElemPatternElemPushHorizontal ExerciseV1ElemPatternElem = "push_horizontal"
const ExerciseV1ElemPatternElemPushVertical ExerciseV1ElemPatternElem = "push_vertical"
const ExerciseV1ElemPatternElemRotation ExerciseV1ElemPatternElem = "rotation"
const ExerciseV1ElemPatternElemShoulderAccessory ExerciseV1ElemPatternElem = "shoulder_accessory"
const ExerciseV1ElemPatternElemSquatKnee ExerciseV1ElemPatternElem = "squat_knee"

var enumValues_ExerciseV1ElemPatternElem = []interface{}{
	"push_horizontal",
	"push_vertical",
	"pull_horizontal",
	"pull_vertical",
	"squat_knee",
	"hinge_hip",
	"brace",
	"rotation",
	"carry",
	"arm_accessory",
	"shoulder_accessory",
	"leg_accessory",
	"isolation_biceps",
	"isolation_triceps",
	"isolation_delts",
	"isolation_quads",
	"isolation_hamstrings",
	"isolation_calves",
	"core_anti_extension",
	"core_anti_rotation",
	"core_rotation",
	"core_flexion",
	"conditioning",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExerciseV1ElemPatternElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExerciseV1ElemPatternElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExerciseV1ElemPatternElem, v)
	}
	*j = ExerciseV1ElemPatternElem(v)
	return nil
}

// Most recent best performance for this exercise; null if unknown.
type ExerciseV1ElemRecentBest struct {
	// Rep range or count (e.g., "8-10" or "10").
	RepBracket string `json:"rep_bracket" yaml:"rep_bracket" mapstructure:"rep_bracket"`

	// Resistance corresponds to the JSON schema field "resistance".
	Resistance ExerciseV1ElemRecentBestResistance `json:"resistance" yaml:"resistance" mapstructure:"resistance"`
}

type ExerciseV1ElemRecentBestResistance struct {
	// Set to true when mode=bodyweight. Set to null otherwise.
	Bodyweight *bool `json:"bodyweight" yaml:"bodyweight" mapstructure:"bodyweight"`

	// Duration in seconds; required when mode=duration. Set to null otherwise.
	DurationSec *float64 `json:"durationSec" yaml:"durationSec" mapstructure:"durationSec"`

	// Additional load in pounds; required when mode=lbs. Set to null otherwise.
	Lbs *float64 `json:"lbs" yaml:"lbs" mapstructure:"lbs"`

	// Discriminator: choose exactly one mode and set the corresponding field. Do not
	// include unused fields.
	Mode ExerciseV1ElemRecentBestResistanceMode `json:"mode" yaml:"mode" mapstructure:"mode"`
}

type ExerciseV1ElemRecentBestResistanceMode string

const ExerciseV1ElemRecentBestResistanceModeBodyweight ExerciseV1ElemRecentBestResistanceMode = "bodyweight"
const ExerciseV1ElemRecentBestResistanceModeDuration ExerciseV1ElemRecentBestResistanceMode = "duration"
const ExerciseV1ElemRecentBestResistanceModeLbs ExerciseV1ElemRecentBestResistanceMode = "lbs"

var enumValues_ExerciseV1ElemRecentBestResistanceMode = []interface{}{
	"lbs",
	"duration",
	"bodyweight",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExerciseV1ElemRecentBestResistanceMode) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExerciseV1ElemRecentBestResistanceMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExerciseV1ElemRecentBestResistanceMode, v)
	}
	*j = ExerciseV1ElemRecentBestResistanceMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExerciseV1ElemRecentBestResistance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["bodyweight"]; raw != nil && !ok {
		return fmt.Errorf("field bodyweight in ExerciseV1ElemRecentBestResistance: required")
	}
	if _, ok := raw["durationSec"]; raw != nil && !ok {
		return fmt.Errorf("field durationSec in ExerciseV1ElemRecentBestResistance: required")
	}
	if _, ok := raw["lbs"]; raw != nil && !ok {
		return fmt.Errorf("field lbs in ExerciseV1ElemRecentBestResistance: required")
	}
	if _, ok := raw["mode"]; raw != nil && !ok {
		return fmt.Errorf("field mode in ExerciseV1ElemRecentBestResistance: required")
	}
	type Plain ExerciseV1ElemRecentBestResistance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DurationSec != nil && 1 > *plain.DurationSec {
		return fmt.Errorf("field %s: must be >= %v", "durationSec", 1)
	}
	if plain.Lbs != nil && 1 > *plain.Lbs {
		return fmt.Errorf("field %s: must be >= %v", "lbs", 1)
	}
	*j = ExerciseV1ElemRecentBestResistance(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExerciseV1ElemRecentBest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["rep_bracket"]; raw != nil && !ok {
		return fmt.Errorf("field rep_bracket in ExerciseV1ElemRecentBest: required")
	}
	if _, ok := raw["resistance"]; raw != nil && !ok {
		return fmt.Errorf("field resistance in ExerciseV1ElemRecentBest: required")
	}
	type Plain ExerciseV1ElemRecentBest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ExerciseV1ElemRecentBest(plain)
	return nil
}

type ExerciseV1ElemTierHint string

const ExerciseV1ElemTierHintA ExerciseV1ElemTierHint = "A"
const ExerciseV1ElemTierHintB ExerciseV1ElemTierHint = "B"
const ExerciseV1ElemTierHintC ExerciseV1ElemTierHint = "C"

var enumValues_ExerciseV1ElemTierHint = []interface{}{
	"A",
	"B",
	"C",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExerciseV1ElemTierHint) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExerciseV1ElemTierHint {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExerciseV1ElemTierHint, v)
	}
	*j = ExerciseV1ElemTierHint(v)
	return nil
}

// Structured history of a user’s workouts based on data provided.
type HistoryV1Json struct {
	// Exercises corresponds to the JSON schema field "exercises".
	Exercises []ExerciseV1 `json:"exercises" yaml:"exercises" mapstructure:"exercises"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HistoryV1Json) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["exercises"]; raw != nil && !ok {
		return fmt.Errorf("field exercises in HistoryV1Json: required")
	}
	type Plain HistoryV1Json
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Exercises != nil && len(plain.Exercises) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "exercises", 1)
	}
	if len(plain.Exercises) > 90 {
		return fmt.Errorf("field %s length: must be <= %d", "exercises", 90)
	}
	*j = HistoryV1Json(plain)
	return nil
}
