// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schemas

import "encoding/json"
import "fmt"
import "github.com/atombender/go-jsonschema/pkg/types"
import "reflect"

type AnalyzerV1Json struct {
	// ExercisePlan corresponds to the JSON schema field "exercise_plan".
	ExercisePlan []AnalyzerV1JsonExercisePlanElem `json:"exercise_plan" yaml:"exercise_plan" mapstructure:"exercise_plan"`

	// FatiguePolicy corresponds to the JSON schema field "fatigue_policy".
	FatiguePolicy AnalyzerV1JsonFatiguePolicy `json:"fatigue_policy" yaml:"fatigue_policy" mapstructure:"fatigue_policy"`

	// InstructionsContext corresponds to the JSON schema field
	// "instructions_context".
	InstructionsContext AnalyzerV1JsonInstructionsContext `json:"instructions_context" yaml:"instructions_context" mapstructure:"instructions_context"`

	// Meta corresponds to the JSON schema field "meta".
	Meta AnalyzerV1JsonMeta `json:"meta" yaml:"meta" mapstructure:"meta"`

	// Session corresponds to the JSON schema field "session".
	Session AnalyzerV1JsonSession `json:"session" yaml:"session" mapstructure:"session"`

	// TimeBudget corresponds to the JSON schema field "time_budget".
	TimeBudget AnalyzerV1JsonTimeBudget `json:"time_budget" yaml:"time_budget" mapstructure:"time_budget"`
}

type AnalyzerV1JsonExercisePlanElem struct {
	// Equipment corresponds to the JSON schema field "equipment".
	Equipment string `json:"equipment" yaml:"equipment" mapstructure:"equipment"`

	// Exercise corresponds to the JSON schema field "exercise".
	Exercise string `json:"exercise" yaml:"exercise" mapstructure:"exercise"`

	// Superset corresponds to the JSON schema field "superset".
	Superset *string `json:"superset" yaml:"superset" mapstructure:"superset"`

	// Targets corresponds to the JSON schema field "targets".
	Targets AnalyzerV1JsonExercisePlanElemTargets `json:"targets" yaml:"targets" mapstructure:"targets"`

	// Tier corresponds to the JSON schema field "tier".
	Tier AnalyzerV1JsonExercisePlanElemTier `json:"tier" yaml:"tier" mapstructure:"tier"`

	// Warmups corresponds to the JSON schema field "warmups".
	Warmups int `json:"warmups" yaml:"warmups" mapstructure:"warmups"`

	// WorkingSets corresponds to the JSON schema field "working_sets".
	WorkingSets int `json:"working_sets" yaml:"working_sets" mapstructure:"working_sets"`
}

type AnalyzerV1JsonExercisePlanElemTargets struct {
	// LoadCap corresponds to the JSON schema field "load_cap".
	LoadCap *float64 `json:"load_cap" yaml:"load_cap" mapstructure:"load_cap"`

	// RepRange corresponds to the JSON schema field "rep_range".
	RepRange string `json:"rep_range" yaml:"rep_range" mapstructure:"rep_range"`

	// Rir corresponds to the JSON schema field "rir".
	Rir *int `json:"rir" yaml:"rir" mapstructure:"rir"`

	// TargetLoad corresponds to the JSON schema field "target_load".
	TargetLoad interface{} `json:"target_load" yaml:"target_load" mapstructure:"target_load"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonExercisePlanElemTargets) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["load_cap"]; raw != nil && !ok {
		return fmt.Errorf("field load_cap in AnalyzerV1JsonExercisePlanElemTargets: required")
	}
	if _, ok := raw["rep_range"]; raw != nil && !ok {
		return fmt.Errorf("field rep_range in AnalyzerV1JsonExercisePlanElemTargets: required")
	}
	if _, ok := raw["rir"]; raw != nil && !ok {
		return fmt.Errorf("field rir in AnalyzerV1JsonExercisePlanElemTargets: required")
	}
	if _, ok := raw["target_load"]; raw != nil && !ok {
		return fmt.Errorf("field target_load in AnalyzerV1JsonExercisePlanElemTargets: required")
	}
	type Plain AnalyzerV1JsonExercisePlanElemTargets
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.RepRange) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "rep_range", 1)
	}
	if plain.Rir != nil && 4 < *plain.Rir {
		return fmt.Errorf("field %s: must be <= %v", "rir", 4)
	}
	if plain.Rir != nil && 0 > *plain.Rir {
		return fmt.Errorf("field %s: must be >= %v", "rir", 0)
	}
	*j = AnalyzerV1JsonExercisePlanElemTargets(plain)
	return nil
}

type AnalyzerV1JsonExercisePlanElemTier string

const AnalyzerV1JsonExercisePlanElemTierA AnalyzerV1JsonExercisePlanElemTier = "A"
const AnalyzerV1JsonExercisePlanElemTierB AnalyzerV1JsonExercisePlanElemTier = "B"
const AnalyzerV1JsonExercisePlanElemTierC AnalyzerV1JsonExercisePlanElemTier = "C"

var enumValues_AnalyzerV1JsonExercisePlanElemTier = []interface{}{
	"A",
	"B",
	"C",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonExercisePlanElemTier) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonExercisePlanElemTier {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonExercisePlanElemTier, v)
	}
	*j = AnalyzerV1JsonExercisePlanElemTier(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonExercisePlanElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["equipment"]; raw != nil && !ok {
		return fmt.Errorf("field equipment in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["exercise"]; raw != nil && !ok {
		return fmt.Errorf("field exercise in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["superset"]; raw != nil && !ok {
		return fmt.Errorf("field superset in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["targets"]; raw != nil && !ok {
		return fmt.Errorf("field targets in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["tier"]; raw != nil && !ok {
		return fmt.Errorf("field tier in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["warmups"]; raw != nil && !ok {
		return fmt.Errorf("field warmups in AnalyzerV1JsonExercisePlanElem: required")
	}
	if _, ok := raw["working_sets"]; raw != nil && !ok {
		return fmt.Errorf("field working_sets in AnalyzerV1JsonExercisePlanElem: required")
	}
	type Plain AnalyzerV1JsonExercisePlanElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Equipment) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "equipment", 1)
	}
	if len(plain.Exercise) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "exercise", 1)
	}
	if 5 < plain.Warmups {
		return fmt.Errorf("field %s: must be <= %v", "warmups", 5)
	}
	if 0 > plain.Warmups {
		return fmt.Errorf("field %s: must be >= %v", "warmups", 0)
	}
	if 10 < plain.WorkingSets {
		return fmt.Errorf("field %s: must be <= %v", "working_sets", 10)
	}
	if 1 > plain.WorkingSets {
		return fmt.Errorf("field %s: must be >= %v", "working_sets", 1)
	}
	*j = AnalyzerV1JsonExercisePlanElem(plain)
	return nil
}

type AnalyzerV1JsonFatiguePolicy struct {
	// LoadCapPct corresponds to the JSON schema field "load_cap_pct".
	LoadCapPct float64 `json:"load_cap_pct" yaml:"load_cap_pct" mapstructure:"load_cap_pct"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// RirShift corresponds to the JSON schema field "rir_shift".
	RirShift int `json:"rir_shift" yaml:"rir_shift" mapstructure:"rir_shift"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonFatiguePolicy) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["load_cap_pct"]; raw != nil && !ok {
		return fmt.Errorf("field load_cap_pct in AnalyzerV1JsonFatiguePolicy: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in AnalyzerV1JsonFatiguePolicy: required")
	}
	if _, ok := raw["rir_shift"]; raw != nil && !ok {
		return fmt.Errorf("field rir_shift in AnalyzerV1JsonFatiguePolicy: required")
	}
	type Plain AnalyzerV1JsonFatiguePolicy
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if 1.1 < plain.LoadCapPct {
		return fmt.Errorf("field %s: must be <= %v", "load_cap_pct", 1.1)
	}
	if 0.5 > plain.LoadCapPct {
		return fmt.Errorf("field %s: must be >= %v", "load_cap_pct", 0.5)
	}
	if 3 < plain.RirShift {
		return fmt.Errorf("field %s: must be <= %v", "rir_shift", 3)
	}
	if -2 > plain.RirShift {
		return fmt.Errorf("field %s: must be >= %v", "rir_shift", -2)
	}
	*j = AnalyzerV1JsonFatiguePolicy(plain)
	return nil
}

type AnalyzerV1JsonInstructionsContext struct {
	// Constraints corresponds to the JSON schema field "constraints".
	Constraints AnalyzerV1JsonInstructionsContextConstraints `json:"constraints" yaml:"constraints" mapstructure:"constraints"`

	// ConstructionRules corresponds to the JSON schema field "construction_rules".
	ConstructionRules AnalyzerV1JsonInstructionsContextConstructionRules `json:"construction_rules" yaml:"construction_rules" mapstructure:"construction_rules"`

	// ExecutionPrinciples corresponds to the JSON schema field
	// "execution_principles".
	ExecutionPrinciples []string `json:"execution_principles" yaml:"execution_principles" mapstructure:"execution_principles"`

	// PrimaryGoals corresponds to the JSON schema field "primary_goals".
	PrimaryGoals []string `json:"primary_goals" yaml:"primary_goals" mapstructure:"primary_goals"`
}

type AnalyzerV1JsonInstructionsContextConstraints struct {
	// Avoid corresponds to the JSON schema field "avoid".
	Avoid []string `json:"avoid" yaml:"avoid" mapstructure:"avoid"`

	// Encourage corresponds to the JSON schema field "encourage".
	Encourage []string `json:"encourage" yaml:"encourage" mapstructure:"encourage"`

	// PreferSingleStation corresponds to the JSON schema field
	// "prefer_single_station".
	PreferSingleStation *bool `json:"prefer_single_station" yaml:"prefer_single_station" mapstructure:"prefer_single_station"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonInstructionsContextConstraints) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["avoid"]; raw != nil && !ok {
		return fmt.Errorf("field avoid in AnalyzerV1JsonInstructionsContextConstraints: required")
	}
	if _, ok := raw["encourage"]; raw != nil && !ok {
		return fmt.Errorf("field encourage in AnalyzerV1JsonInstructionsContextConstraints: required")
	}
	if _, ok := raw["prefer_single_station"]; raw != nil && !ok {
		return fmt.Errorf("field prefer_single_station in AnalyzerV1JsonInstructionsContextConstraints: required")
	}
	type Plain AnalyzerV1JsonInstructionsContextConstraints
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AnalyzerV1JsonInstructionsContextConstraints(plain)
	return nil
}

type AnalyzerV1JsonInstructionsContextConstructionRules struct {
	// Format corresponds to the JSON schema field "format".
	Format AnalyzerV1JsonInstructionsContextConstructionRulesFormat `json:"format" yaml:"format" mapstructure:"format"`

	// PriorityOrder corresponds to the JSON schema field "priority_order".
	PriorityOrder []AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem `json:"priority_order" yaml:"priority_order" mapstructure:"priority_order"`

	// RestBetweenSupersetsSec corresponds to the JSON schema field
	// "rest_between_supersets_sec".
	RestBetweenSupersetsSec *int `json:"rest_between_supersets_sec" yaml:"rest_between_supersets_sec" mapstructure:"rest_between_supersets_sec"`
}

type AnalyzerV1JsonInstructionsContextConstructionRulesFormat string

const AnalyzerV1JsonInstructionsContextConstructionRulesFormatGiantSets AnalyzerV1JsonInstructionsContextConstructionRulesFormat = "giant_sets"
const AnalyzerV1JsonInstructionsContextConstructionRulesFormatStraightSets AnalyzerV1JsonInstructionsContextConstructionRulesFormat = "straight_sets"
const AnalyzerV1JsonInstructionsContextConstructionRulesFormatSupersets AnalyzerV1JsonInstructionsContextConstructionRulesFormat = "supersets"

var enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesFormat = []interface{}{
	"supersets",
	"giant_sets",
	"straight_sets",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonInstructionsContextConstructionRulesFormat) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesFormat {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesFormat, v)
	}
	*j = AnalyzerV1JsonInstructionsContextConstructionRulesFormat(v)
	return nil
}

type AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem string

const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemBigCompound AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "big_compound"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemConditioning AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "conditioning"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemCoreStability AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "core_stability"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemHypertrophyCompound AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "hypertrophy_compound"
const AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElemIsolationFinishers AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = "isolation_finishers"

var enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem = []interface{}{
	"big_compound",
	"hypertrophy_compound",
	"core_stability",
	"isolation_finishers",
	"conditioning",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem, v)
	}
	*j = AnalyzerV1JsonInstructionsContextConstructionRulesPriorityOrderElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonInstructionsContextConstructionRules) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["format"]; raw != nil && !ok {
		return fmt.Errorf("field format in AnalyzerV1JsonInstructionsContextConstructionRules: required")
	}
	if _, ok := raw["priority_order"]; raw != nil && !ok {
		return fmt.Errorf("field priority_order in AnalyzerV1JsonInstructionsContextConstructionRules: required")
	}
	if _, ok := raw["rest_between_supersets_sec"]; raw != nil && !ok {
		return fmt.Errorf("field rest_between_supersets_sec in AnalyzerV1JsonInstructionsContextConstructionRules: required")
	}
	type Plain AnalyzerV1JsonInstructionsContextConstructionRules
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.PriorityOrder != nil && len(plain.PriorityOrder) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "priority_order", 1)
	}
	if plain.RestBetweenSupersetsSec != nil && 300 < *plain.RestBetweenSupersetsSec {
		return fmt.Errorf("field %s: must be <= %v", "rest_between_supersets_sec", 300)
	}
	if plain.RestBetweenSupersetsSec != nil && 0 > *plain.RestBetweenSupersetsSec {
		return fmt.Errorf("field %s: must be >= %v", "rest_between_supersets_sec", 0)
	}
	*j = AnalyzerV1JsonInstructionsContextConstructionRules(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonInstructionsContext) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["constraints"]; raw != nil && !ok {
		return fmt.Errorf("field constraints in AnalyzerV1JsonInstructionsContext: required")
	}
	if _, ok := raw["construction_rules"]; raw != nil && !ok {
		return fmt.Errorf("field construction_rules in AnalyzerV1JsonInstructionsContext: required")
	}
	if _, ok := raw["execution_principles"]; raw != nil && !ok {
		return fmt.Errorf("field execution_principles in AnalyzerV1JsonInstructionsContext: required")
	}
	if _, ok := raw["primary_goals"]; raw != nil && !ok {
		return fmt.Errorf("field primary_goals in AnalyzerV1JsonInstructionsContext: required")
	}
	type Plain AnalyzerV1JsonInstructionsContext
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ExecutionPrinciples != nil && len(plain.ExecutionPrinciples) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "execution_principles", 1)
	}
	if plain.PrimaryGoals != nil && len(plain.PrimaryGoals) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "primary_goals", 1)
	}
	*j = AnalyzerV1JsonInstructionsContext(plain)
	return nil
}

type AnalyzerV1JsonMeta struct {
	// Date corresponds to the JSON schema field "date".
	Date types.SerializableDate `json:"date" yaml:"date" mapstructure:"date"`

	// DurationMinutes corresponds to the JSON schema field "duration_minutes".
	DurationMinutes int `json:"duration_minutes" yaml:"duration_minutes" mapstructure:"duration_minutes"`

	// Goal corresponds to the JSON schema field "goal".
	Goal string `json:"goal" yaml:"goal" mapstructure:"goal"`

	// Location corresponds to the JSON schema field "location".
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// Units corresponds to the JSON schema field "units".
	Units AnalyzerV1JsonMetaUnits `json:"units" yaml:"units" mapstructure:"units"`
}

type AnalyzerV1JsonMetaUnits string

const AnalyzerV1JsonMetaUnitsKg AnalyzerV1JsonMetaUnits = "kg"
const AnalyzerV1JsonMetaUnitsLbs AnalyzerV1JsonMetaUnits = "lbs"

var enumValues_AnalyzerV1JsonMetaUnits = []interface{}{
	"lbs",
	"kg",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonMetaUnits) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonMetaUnits {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonMetaUnits, v)
	}
	*j = AnalyzerV1JsonMetaUnits(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonMeta) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["date"]; raw != nil && !ok {
		return fmt.Errorf("field date in AnalyzerV1JsonMeta: required")
	}
	if _, ok := raw["duration_minutes"]; raw != nil && !ok {
		return fmt.Errorf("field duration_minutes in AnalyzerV1JsonMeta: required")
	}
	if _, ok := raw["goal"]; raw != nil && !ok {
		return fmt.Errorf("field goal in AnalyzerV1JsonMeta: required")
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in AnalyzerV1JsonMeta: required")
	}
	if _, ok := raw["units"]; raw != nil && !ok {
		return fmt.Errorf("field units in AnalyzerV1JsonMeta: required")
	}
	type Plain AnalyzerV1JsonMeta
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if 180 < plain.DurationMinutes {
		return fmt.Errorf("field %s: must be <= %v", "duration_minutes", 180)
	}
	if 10 > plain.DurationMinutes {
		return fmt.Errorf("field %s: must be >= %v", "duration_minutes", 10)
	}
	if len(plain.Goal) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "goal", 1)
	}
	if len(plain.Location) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "location", 1)
	}
	*j = AnalyzerV1JsonMeta(plain)
	return nil
}

type AnalyzerV1JsonSession struct {
	// CutOrder corresponds to the JSON schema field "cut_order".
	CutOrder []AnalyzerV1JsonSessionCutOrderElem `json:"cut_order" yaml:"cut_order" mapstructure:"cut_order"`

	// Tiers corresponds to the JSON schema field "tiers".
	Tiers []AnalyzerV1JsonSessionTiersElem `json:"tiers" yaml:"tiers" mapstructure:"tiers"`

	// Type corresponds to the JSON schema field "type".
	Type AnalyzerV1JsonSessionType `json:"type" yaml:"type" mapstructure:"type"`
}

type AnalyzerV1JsonSessionCutOrderElem string

const AnalyzerV1JsonSessionCutOrderElemA AnalyzerV1JsonSessionCutOrderElem = "A"
const AnalyzerV1JsonSessionCutOrderElemB AnalyzerV1JsonSessionCutOrderElem = "B"
const AnalyzerV1JsonSessionCutOrderElemC AnalyzerV1JsonSessionCutOrderElem = "C"

var enumValues_AnalyzerV1JsonSessionCutOrderElem = []interface{}{
	"A",
	"B",
	"C",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonSessionCutOrderElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonSessionCutOrderElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonSessionCutOrderElem, v)
	}
	*j = AnalyzerV1JsonSessionCutOrderElem(v)
	return nil
}

type AnalyzerV1JsonSessionTiersElem string

const AnalyzerV1JsonSessionTiersElemA AnalyzerV1JsonSessionTiersElem = "A"
const AnalyzerV1JsonSessionTiersElemB AnalyzerV1JsonSessionTiersElem = "B"
const AnalyzerV1JsonSessionTiersElemC AnalyzerV1JsonSessionTiersElem = "C"

var enumValues_AnalyzerV1JsonSessionTiersElem = []interface{}{
	"A",
	"B",
	"C",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonSessionTiersElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonSessionTiersElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonSessionTiersElem, v)
	}
	*j = AnalyzerV1JsonSessionTiersElem(v)
	return nil
}

type AnalyzerV1JsonSessionType string

const AnalyzerV1JsonSessionTypeCustom AnalyzerV1JsonSessionType = "custom"
const AnalyzerV1JsonSessionTypeFatLoss AnalyzerV1JsonSessionType = "fat_loss"
const AnalyzerV1JsonSessionTypeFullBody AnalyzerV1JsonSessionType = "full_body"
const AnalyzerV1JsonSessionTypeHypertrophy AnalyzerV1JsonSessionType = "hypertrophy"
const AnalyzerV1JsonSessionTypeLower AnalyzerV1JsonSessionType = "lower"
const AnalyzerV1JsonSessionTypeMaintenance AnalyzerV1JsonSessionType = "maintenance"
const AnalyzerV1JsonSessionTypePower AnalyzerV1JsonSessionType = "power"
const AnalyzerV1JsonSessionTypePull AnalyzerV1JsonSessionType = "pull"
const AnalyzerV1JsonSessionTypePush AnalyzerV1JsonSessionType = "push"
const AnalyzerV1JsonSessionTypeStrength AnalyzerV1JsonSessionType = "strength"
const AnalyzerV1JsonSessionTypeUpper AnalyzerV1JsonSessionType = "upper"

var enumValues_AnalyzerV1JsonSessionType = []interface{}{
	"hypertrophy",
	"strength",
	"power",
	"maintenance",
	"fat_loss",
	"upper",
	"lower",
	"push",
	"pull",
	"full_body",
	"custom",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonSessionType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnalyzerV1JsonSessionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnalyzerV1JsonSessionType, v)
	}
	*j = AnalyzerV1JsonSessionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonSession) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["cut_order"]; raw != nil && !ok {
		return fmt.Errorf("field cut_order in AnalyzerV1JsonSession: required")
	}
	if _, ok := raw["tiers"]; raw != nil && !ok {
		return fmt.Errorf("field tiers in AnalyzerV1JsonSession: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AnalyzerV1JsonSession: required")
	}
	type Plain AnalyzerV1JsonSession
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.CutOrder != nil && len(plain.CutOrder) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "cut_order", 1)
	}
	if plain.Tiers != nil && len(plain.Tiers) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "tiers", 1)
	}
	*j = AnalyzerV1JsonSession(plain)
	return nil
}

type AnalyzerV1JsonTimeBudget struct {
	// EstimatedMinutesTotal corresponds to the JSON schema field
	// "estimated_minutes_total".
	EstimatedMinutesTotal *int `json:"estimated_minutes_total" yaml:"estimated_minutes_total" mapstructure:"estimated_minutes_total"`

	// TargetSetCount corresponds to the JSON schema field "target_set_count".
	TargetSetCount int `json:"target_set_count" yaml:"target_set_count" mapstructure:"target_set_count"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1JsonTimeBudget) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["estimated_minutes_total"]; raw != nil && !ok {
		return fmt.Errorf("field estimated_minutes_total in AnalyzerV1JsonTimeBudget: required")
	}
	if _, ok := raw["target_set_count"]; raw != nil && !ok {
		return fmt.Errorf("field target_set_count in AnalyzerV1JsonTimeBudget: required")
	}
	type Plain AnalyzerV1JsonTimeBudget
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EstimatedMinutesTotal != nil && 180 < *plain.EstimatedMinutesTotal {
		return fmt.Errorf("field %s: must be <= %v", "estimated_minutes_total", 180)
	}
	if plain.EstimatedMinutesTotal != nil && 10 > *plain.EstimatedMinutesTotal {
		return fmt.Errorf("field %s: must be >= %v", "estimated_minutes_total", 10)
	}
	if 50 < plain.TargetSetCount {
		return fmt.Errorf("field %s: must be <= %v", "target_set_count", 50)
	}
	if 1 > plain.TargetSetCount {
		return fmt.Errorf("field %s: must be >= %v", "target_set_count", 1)
	}
	*j = AnalyzerV1JsonTimeBudget(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalyzerV1Json) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["exercise_plan"]; raw != nil && !ok {
		return fmt.Errorf("field exercise_plan in AnalyzerV1Json: required")
	}
	if _, ok := raw["fatigue_policy"]; raw != nil && !ok {
		return fmt.Errorf("field fatigue_policy in AnalyzerV1Json: required")
	}
	if _, ok := raw["instructions_context"]; raw != nil && !ok {
		return fmt.Errorf("field instructions_context in AnalyzerV1Json: required")
	}
	if _, ok := raw["meta"]; raw != nil && !ok {
		return fmt.Errorf("field meta in AnalyzerV1Json: required")
	}
	if _, ok := raw["session"]; raw != nil && !ok {
		return fmt.Errorf("field session in AnalyzerV1Json: required")
	}
	if _, ok := raw["time_budget"]; raw != nil && !ok {
		return fmt.Errorf("field time_budget in AnalyzerV1Json: required")
	}
	type Plain AnalyzerV1Json
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ExercisePlan != nil && len(plain.ExercisePlan) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "exercise_plan", 1)
	}
	*j = AnalyzerV1Json(plain)
	return nil
}
